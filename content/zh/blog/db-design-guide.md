---
title: "DB设计指南"
linkTitle: "DB设计指南"
date: 2016-03-08
description: >
  数据库设计中有哪些常见误区、难点及挑战？如何应对？
---

## 为什么

### 设计常见误区

+ 名称不当/不统一
+ 数据类型不合适
+ 索引或约束建立不当
+ 滥用json格式大字段存储
+ 过分遵守/破坏范式
+ etc ...


### 常见难点/挑战

+ 哪些设计可提供读/写性能？海量数据查询、高并发读/写？
+ 如何实现可扩展性？
+ 如何实现高可用性？
+ 若拆分，如何选择合适的拆分方案？事务等注意事项？
+ etc ...


## 设计目标

要达到怎样的效果？

数据库设计目标

用户角度: 响应时间、可用性
管理员角度: 服务器资源使用率、系统吞吐量
开发（设计）人员角度: 设计是否合理、可扩展性

具体的设计则和不同的业务场景有关，不同类型的业务场景做法会不一样

主要业务场景

数据库定位：传统关系型（OLTP、OLAP）、分布式数据库、NoSQL

+ 业务角度：清晰、数据完整、应对变化（弹性）
+ 架构角度：性能（可用性、一致性、可扩展性）、安全、审计

哪些是关键指标？

如何做到？


## 方法论

一般步骤

各个环节中的目的？输入输出？一般步骤/方法？关注点/注意事项？要做到什么程度？

基本原则：逐步细化、迭代设计

### 能否与领域建模结合？如何做？


### 确定哪些输入输出是必须项、哪些可省？步骤可否简化？简洁易记忆/实施？


### 需求分析

摸清用户的真实需求、发掘隐藏的用户需求


### 概念设计

对业务范围和使用进行抽象概括，划分主题域

+ 目的：对关键业务实体、实体关系、相关业务规则建模，形成高层次的实体关系图
+ 输入：需求文档、现有系统分析，业务目标、范围和定位
+ 输出：概念ERD、概念DFD、概念阶段事件列表、概念阶段交叉校验、业务场景验证文档、业务功能与角色对应关系

设计步骤

注意事项


### 逻辑设计

对概念模型中主题进行细化，定义实体与实体之间的关系，即实体属性

+ 输入：概念阶段的输出物；需求类文档
+ 输出：逻辑阶段ERD、逻辑阶段DFD、逻辑阶段交叉校验、概念阶段与逻辑阶段实体对应关系、概念阶段与逻辑阶段功能（活动）对应关系、业务场景验证文档、功能列表


### 物理设计

结合具体使用的数据库管理系统，加入对系统实现的考虑，包括系统的可实现性、系统的性能等。从实现的角度，在逻辑模型的基础上做必要的反向规范化的设计、模型物理结构的设计，加入程序控制和动作控制。

+ 输入：逻辑阶段的输出物；需求类文档。
+ 输出：物理阶段ERD、物理阶段DFD、物理阶段与逻辑阶段实体对应关系、物理阶段与逻辑阶段功能对应关系、功能列表。

设计步骤

注意事项

性能需求

性能关注点:

+ 数据量: 初始数据量有多少，每天或者每月的数据增量是多少？每天或者每月每个功能的数据增量是多少？
+ 响应时间: 关键业务的响应时间是多少
+ 并发: 高并发的业务（功能）是哪些？多少的并发量？
+ 热点(数据的存取频度): 最多的数据读写发生在哪些表上？


#### 如何预估数据量？

系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间
QPS（TPS）= 并发数/平均响应时间

数据量还是访问量？
读写请求各占多少？
冷热数据如何分布？

系统未上线，根据目标

系统已上线，运行过一段时间，根据历史数据

1. 找出系统的最高TPS和日PV
2. 通过压力测试或者经验预估，得出最高TPS，然后跟进1的关系，计算出系统最高的日吞吐量。

网站: PageView, UV
每个用户可能产生的数据量大概多大，分固定部分，以及动态部分的方式统计分析
日/周/月/年活跃用户量大概多少？系统设计的最高并发量为多少？

根据应用业务的特点，以及系统不同模块的功能特点，初期必须判断出可能负载最大的系统模块，对于可以静态化模块或功能，尽量要Cache起来，以降低系统的负载和提高前端响应速度；
若是非Cache技术能解决的，是否可以考虑独立或通过整体水平扩展方式解决系统的负载和性能问题；

读写比例
SELECT:INSERT:UPDATE:DELETE=？

数据库的设计开始之前，必须优先进行业务的数据流梳理（注释：必须尽量考虑应用所有可能的功能模块），以及对业务优先进行优化和规划，然后根据数据流和功能 考虑数据库的结构设计和优化；
千万级别用户量，建议考虑用户数据拆分架构设计，以及考虑后续未来1-2年的承受量
数据拆分的核心与难处：同一个用户的数据尽量放一起（拆分规则要尽量简单可执行），拆分之后用户关系的数据如何保存的抉择有多种（存2份或存1份放一个地方），难处数据的分页，统计合并等；


## 最佳实践

一些具体的规范或建议以达到相应的设计目标

### 命名规范

基本命名原则: 命名使用具有意义的英文词汇，词汇中间以下划线分隔; 避免使用SQL和数据库引擎特定关键词的名字

注：`mysql`默认区分大小写，`idb`中已设置为不区分大小写（建议统一小写）。

数据库名: 库名与应用名称尽量一致

表名: 表的命名最好是加上`业务名称_表的作用`

字段名: 各表之间相同意义的字段应同名

外键: 外键字段用`表名_字段名`表示其关联关系

索引/约束: `primary key`以`pk_`开头；`unique key`以`uk_`开头；`normal index`以`idx_`开头

触发器: 以`trg_`开头

函数过程: 过程的命名以`prc_`开头，函数以`fuc_`开头


### 数据设计

数据量大小、增加率、读写比例

+ 核心数据：需要长期保留在数据库的活跃数据，是整个商业活动中最有价值的数据,需要长期甚至永久的保留，往往覆盖大部分业务
+ 过程数据：程序完成处理后只需要备查的休眠数据，伴随核心数据(实体)流动所产生的数据；存在周期视商业活动的重要性而定，过程数据只是针对单一面积的应用场景下有效,作用域较为狭窄

原则

+ 核心数据和过程数据严格分离
+ 不同的管道数据使用不同的存储池
+ 核心数据尽可能只包含必要属性
+ 作用域


### 表设计

+ 核心表: 生命周期长,贯穿业务的始末,处于数据的顶层,多以实体为主
    - 衡数表: 数据量小, 几乎不写, 读多, 数据基本不流动不增长. 
        - 如国家的省、市、县等固定信息.
    - 递增表: 数据量大(千万至亿级),很少写,读多; 数据很少流动,每次只访问表中很少的数据;
        - 如会员信息
+ 过程表: 生命周期短,覆盖范围为特定场景,有多层数据结构,多以事实和触发数据为主
    - 流水表: 数据量大,增长很快,读写多; 通常只增不改,主要用于备查,要求定期清理或转储.
        - 如日志,交易信息等
    - 状态表: 数据量大小均有,读写频繁; 边插边改边删,数据在不同的表之间流动.
        - 如规则配置表,信息下发表

原则:

+ 设计表时, 建议将以上2种数据类型和对应的4中表进行划分（清晰且性能好）


### 数据类型选择

数值型

字符型

日期型

实数型

大对象

其他


### 主键

自增

Oracle Sequence 单点

TDDL Sequence


### 索引

索引的分类？

优缺点？

#### 如何选择索引？

+ 选择在where子句中出现，且选择性和过滤性高的字段创建索引
+ 用来和其他表关联的字段，如果使用nest loop join，建议创建索引
+ 索引的首字段，必须在where条件中
+ 复合索引，将选择性高的字段放在前面

#### 使用注意事项?



### 约束


### 规范化

为什么需要范式化？可以解决什么问题？

可能会带来什么新的问题？


### 反规范化

常见的反模式

一列多值

用逗号等分隔多个值，用json串储存多个key-value信息

目的： 在不改变表结构的前提下，用一对一形式实现一对多关系

问题：

+ 查询困难
+ 无法使用聚合函数
+ 数据验证无法利用外键和数据类型做限制
+ 更新困难
+ 分隔符选择
+ 长度限制


合理使用

+ 数据消费时，没必要使用单独项
+ 源数据就是逗号分隔的形式，同时只有存储和使用，不做任何修改操作


### 如何权衡范式与反范式？

## 架构设计最佳实践

### 扩展性

为什么需要扩展？什么时候需要考虑？基本原则？各个方法的优缺点及场景？

#### 数据扩容

#### 扩展字段

是否要考虑预留字段？

不建议使用

#### 垂直拆分

如对用户数据、商品数据、交易数据等，它们之间的联系不是很紧密，可以存放在不同的数据库中，这样就可实现了垂直分区。

#### 水平拆分

为什么要分库分表？

如何拆分？按`id`,日期，类型，区域进行分割?

+ 数据量分析
+ 数据特点分析
+ 查询的维度

尽量选择简单的拆分方案
最难的不是如何拆，而是拆了之后，需要继续较为灵活的支持业务发展的需要

涉及多个维度的查询该如何处理？

+ 冗余表+binlog同步; 中间路由表; 搜索引擎; 允许跨库；

冗余表的优缺点？

拆分的优缺点？如何权衡？

基本原则

+ 使用较为均匀的拆分维度。尽量让落在各个库里的数据量，都比较均衡
+ 拆分维度需要尽量避免跨库事务
+ 拆分维度需要尽量避免跨库查询

规范

+ 拆分的表标准：单表数据记录数1千万条以上，同时表空间10G以上
+ 拆分的表禁止使用跨库事务、跨库排序、跨库分页、跨库join
+ 拆分的表禁止使用无查询条件的select *, select count *等查询操作
+ 拆分的表的sql语句insert操作必须加上列名
+ 拆分的表所有sql语句必须包含拆分字段作为where条件


### 一致性

主从不一致
缓存不一致

为什么会不一致？

是否需要强一致？如何保证？

如何优化？设计阶段有应考虑哪些内容？


### 可用性

基本思路：冗余
冗余会带来什么问题？

不一致如何解决？

如何解决读高可用？写高可用？


### TDDL让分库分表变的很容易，我们是否应该一开始就考虑分库分表？

TDDL虽然使分库分表变的容易，但跨数据库访问不便，事务也无法跨数据源使用。

是否应优先考虑一些其他的方案，循序渐进的设计？

线上库与历史库
如果仅是容量问题，而且历史数据的查询频率及查询效率要求相对不高，并且历史数据不存在更新的操作，那么历史数据可以考虑定期迁往历史库，历史库可以提供查询功能。如日志类，操作记录类数据，或者历史仅可读数据

单库多表

### 如何评估设计结果？是否设计不足，或者过度设计？标准？

分离变化，预计变化？

